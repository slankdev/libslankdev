
#pragma once

#include <slankdev/net/mbuf.h>
#include <slankdev/net/hdr.h>
#include <slankdev/checksum.h>
#include <slankdev/endian.h>
#include <slankdev/hash.h>


namespace slankdev {

inline const uint8_t* raw_arp_pack()
{
  static uint8_t arp_packet[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x11, 0x22,
    0x33, 0x44, 0x55, 0x66, 0x08, 0x06, 0x00, 0x01,
    0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00,
  };
  return arp_packet;
}

inline const uint8_t* raw_tcp_pack()
{
  static uint8_t tcp_packet[] = {
    0x84, 0xdb, 0xac, 0x31, 0x1d, 0xfa, 0x80, 0xe6,
    0x50, 0x17, 0x18, 0x46, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x80, 0x91, 0xb3, 0x40, 0x00, 0x40, 0x06,
    0x3b, 0x57, 0xc0, 0xa8, 0x64, 0x67, 0xa3, 0x2c,
    0xa5, 0x31, 0x81, 0x42, 0x00, 0x50, 0x9b, 0x4c,
    0x6e, 0x59, 0x4a, 0x9e, 0x73, 0x7e, 0x80, 0x18,
    0x00, 0xe5, 0x54, 0xd9, 0x00, 0x00, 0x01, 0x01,
    0x08, 0x0a, 0x00, 0x18, 0x00, 0x16, 0x4e, 0xf8,
    0xcd, 0x22, 0x47, 0x45, 0x54, 0x20, 0x2f, 0x20,
    0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31,
    0x0d, 0x0a, 0x48, 0x6f, 0x73, 0x74, 0x3a, 0x20,
    0x73, 0x6c, 0x61, 0x6e, 0x6b, 0x64, 0x65, 0x76,
    0x2e, 0x6e, 0x65, 0x74, 0x0d, 0x0a, 0x55, 0x73,
    0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74,
    0x3a, 0x20, 0x63, 0x75, 0x72, 0x6c, 0x2f, 0x37,
    0x2e, 0x35, 0x30, 0x2e, 0x33, 0x0d, 0x0a, 0x41,
    0x63, 0x63, 0x65, 0x70, 0x74, 0x3a, 0x20, 0x2a,
    0x2f, 0x2a, 0x0d, 0x0a, 0x0d, 0x0a,
  };
  return tcp_packet;
}



class packet {
 public:
  virtual ~packet() {}
  virtual void summary() const = 0;
};


class udp_packet : public packet {
 public:
  slankdev::mbuf   m;
  slankdev::udp*   uh;
  slankdev::ip*    ih;
  slankdev::ether* eh;
  udp_packet();

  void show() const;
  uint32_t hash() const;
  virtual void summary() const override;
};


inline uint32_t udp_packet::hash() const
{
  using namespace slankdev;
  rss_tuple rt;
  rt.src_addr = ntohl(ih->src.s_addr);
  rt.dst_addr = ntohl(ih->dst.s_addr);
  rt.sport    = ntohs(uh->src);
  rt.dport    = ntohs(uh->dst);

  return rt.hash(rss_key_def());
}


inline void udp_packet::summary() const
{
  printf("%s:%d -> %s:%d  0x%08x\n",
      ih->src.to_string().c_str(), ntohs(uh->src),
      ih->dst.to_string().c_str(), ntohs(uh->dst), hash());
}


inline udp_packet::udp_packet()
{
  const char* str = "slankdev";

  m.prepend(strlen(str));
  uint8_t* d = m.mtod();
  memcpy(d, str, strlen(str));

  m.prepend(sizeof(slankdev::udp));
  uh = reinterpret_cast<slankdev::udp*>(m.mtod());
  uh->src = htons(2794);
  uh->dst = htons(1766);

  uh->src = htons(0);
  uh->dst = htons(0);

  uh->len = m.dlen();
  uh->cksum = htons(0x0000);

  m.prepend(sizeof(slankdev::ip));
  ih = reinterpret_cast<slankdev::ip*>(m.mtod());
  ih->ver   = 4;
  ih->ihl   = 5;
  ih->len   = htons(m.dlen());
  ih->proto = 0x11;
  ih->sum   = htons(0x0000);
  ih->src.s_addr = htonl(0x420995bb);
  ih->dst.s_addr = htonl(0xa18e6450);

  m.prepend(sizeof(slankdev::ether));
  eh = reinterpret_cast<slankdev::ether*>(m.mtod());
  eh->type = htons(0x0800);
}


inline void udp_packet::show() const
{
  m.dump(stdout);
  printf("\n");
  eh->print();
  ih->print();
  uh->print();
}


} /* namespace slankdev */
